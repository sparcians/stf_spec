from __future__ import annotations
import __main__
from pathlib import Path
from typing import Any, Optional, TextIO, Union
from typing_extensions import TypedDict

from lib.constants import GENERATED_DIR
from lib.types import EnumDict, RecordDict, ChannelDict, ProtocolDict

class AsciiDocGenerator:
    def __init__(self,
                 filename: Union[str, Path],
                 dir: Union[str, Path, None] = None,
                 src_file: Union[str, Path, None] = None) -> None:
        if dir is None:
            dir = GENERATED_DIR
        self._filename = Path(dir) / filename
        self._src_file = src_file
        self._fp: Optional[TextIO] = None

    def __enter__(self) -> AsciiDocGenerator:
        self._fp = open(self._filename, 'w')
        self.write_line('////')
        self.write_line(
            f'DO NOT EDIT. This file was autogenerated by {Path(__main__.__file__).name}.'
        )
        if self._src_file:
            self.write_line(
                f'To make changes to this file, edit {self._src_file} and then run make.'
            )
        self.write_line('////')
        return self

    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        if self._fp is not None:
            self._fp.close()

    def define_var(self, var_name: str, var_value: str):
        self.write_line(f':{var_name}: {var_value}')

    def include(self,
                include_file: Union[str, Path],
                tag: Optional[str] = None) -> None:
        tag_str = f'tag={tag}' if tag else ''
        self.write_line(f'include::{include_file}[{tag_str}]')

    def write(self, string: str) -> None:
        assert self._fp is not None
        self._fp.write(string)

    def write_line(self, string: Optional[str] = None) -> None:
        if string is None:
            string = ''
        self.write(f'{string}\n')

    def write_fields(self, data: Union[RecordDict, ChannelDict]) -> None:
        if 'fields' in data:
            for field in data['fields']:
                start_idx = field['start']
                bit_range = str(start_idx)
                if 'end' in field:
                    end_idx = field['end']
                    if isinstance(end_idx, int) and isinstance(start_idx, int) and end_idx < start_idx:
                        raise RuntimeError(f"Field end index {end_idx} should be >= start index {start_idx} in {self._src_file}")
                    if end_idx != start_idx:
                        bit_range = f'{field["end"]}:' + bit_range
                self.write_line(f'* b[{bit_range}] {field["desc"]}')
        else:
            self.write_line('b[-1] Record has no data, just the descriptor.')

    def format_enum(self, enum_info: EnumDict) -> str:
        return f'{enum_info["name"]} ({enum_info["val"]})'

    def define_enum(self,
                    enum_var: str,
                    enum_info: EnumDict) -> None:
        self.define_var(enum_var, self.format_enum(enum_info))
